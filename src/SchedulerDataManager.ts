import moment from 'moment';
import { rrulestr } from 'rrule';
import config from './constants';
import {
  CustomSchedulerDate,
  Event,
  EventGroup,
  Resource,
  SchedulerDataConfig,
  XAxisHeader,
  SchedulerDimension,
  XAxis,
  YAxis,
  RenderedEvent,
  SchedulerSource,
} from './interface';
import { TimePeriods, CellUnits, ViewTypes, YAxisDataTypes } from './enum';
import { DATETIME_FORMAT } from './constants';
import { isWorkingTime } from './_util/isWorkingTime';
import { ViewType, TimePeriod } from './Scheduler';

interface InitProps {
  currentDate: string;
  events: Event[];
  language: string;
  minuteStep: number;
  newConfig: any;
  resources: Resource[];
  timePeriod: TimePeriod;
  viewType: ViewType;
  yAxisType: YAxisDataType;
  customFunc: CustomSchedulerFunc;
}

export interface CustomSchedulerFunc {
  getCustomSchedulerDate?: (
    data: SchedulerDataManger,
    num: number,
    date?: string,
  ) => CustomSchedulerDate;
  getSummary?: () => void;
}

export type YAxisDataType = 'resource' | 'event';

export class SchedulerDataManger {
  public cellUnit: number;
  public config: SchedulerDataConfig;
  public customFunc?: CustomSchedulerFunc;

  public eventGroups: EventGroup[];
  public eventGroupsAutoGenerated: boolean;
  public events: Event[];
  public headers: XAxisHeader[];
  public language: string;
  public localeMoment: typeof moment;
  public renderedEvents: RenderedEvent[];
  public resizing: boolean;
  public resources: any[];
  public scrollToSpecialMoment: boolean;
  public yAxisDataType: YAxisDataType;

  // Scheduler's dimensions.
  private dimensions: SchedulerDimension;

  /**
   * timePeriod is the initial view type, now Scheduler supports Day, Week, Month, Quarter, Year
   * 5 built-in view types, in addition Scheduler now supports Custom, Custom1, Custom2 3
   * custom view types at the same time, in which you can control the time window yourself
   */
  private timePeriod: TimePeriod;
  private viewType: ViewType;

  // Date range.
  private currentDate: moment.Moment;
  private endDate: moment.Moment;
  private startDate: moment.Moment;

  // Default value is 23.
  private endTimeOfDay: number;

  // Default value is 0.
  private startTimeOfDay: number;

  private minuteStep: number;

  // Line height of an event.
  private eventHeight: number;

  // An array of X, Y Axis.
  private xAxis: XAxis[];
  private yAxis: YAxis[];

  // Height per slot.
  private yAxisHeight: number;

  constructor(args: Partial<InitProps>) {
    this.resources = args.resources || [];
    this.events = args.events || [];
    this.eventGroups = [];
    this.eventGroupsAutoGenerated = true;
    this.headers = [];
    this.timePeriod = args.timePeriod || (TimePeriods.Week as TimePeriod);
    this.cellUnit =
      args.timePeriod && args.timePeriod === TimePeriods.Day ? CellUnits.Hour : CellUnits.Day;
    this.config = config;
    this.viewType = args.viewType || (ViewTypes.Timeline as ViewType);
    this.yAxisDataType = args.yAxisType || (YAxisDataTypes.Resource as YAxisDataType);
    this.renderedEvents = [];
    this.resizing = false;
    this.scrollToSpecialMoment = false;
    this.language = args.language || 'en';
    this.localeMoment = moment;

    this.currentDate =
      this.localeMoment(args.currentDate, DATETIME_FORMAT) ||
      this.localeMoment(new Date(), DATETIME_FORMAT);
    this.startTimeOfDay = 0;
    this.endTimeOfDay = 23;
    this.minuteStep = args.minuteStep || 60;
    this.yAxisHeight = 40;
    this.eventHeight = 30;

    this.dimensions = {
      containerWidth: 0,
      dataHeight: 0,
      dataWidth: 0,
      dataSlotWidth: 0,
      minimumDataSlotWidth: 0,
      labelWidth: 0,
    };

    this.validateMinuteStep(this.minuteStep);
    this.customFunc = args.customFunc || undefined;
    this.resolveDateRange(this.currentDate);
    this.reloadAll();
  }

  public addEventGroup(eventGroup: EventGroup) {
    const existedEventGroups = this.eventGroups.filter(x => x.id === eventGroup.id);
    if (existedEventGroups.length === 0) {
      this.eventGroups.push(eventGroup);
      this.generateRenderedEvents();
    }
  }

  public addResource(resource: Resource) {
    const existedResources = this.resources.filter(x => x.id === resource.id);
    if (existedResources.length === 0) {
      this.resources.push(resource);
      this.generateRenderedEvents();
    }
  }

  public getDateTitle() {
    if (this.timePeriod === TimePeriods.Week) {
      if (this.startDate.year() !== this.endDate.year()) {
        return `${this.startDate.format('MMM D, YYYY')}-${this.endDate.format('MMM D, YYYY')}`;
      } else if (this.startDate.month() !== this.endDate.month()) {
        return `${this.startDate.format('MMM D')}-${this.endDate.format('MMM D, YYYY')}`;
      }

      return `${this.startDate.format('MMM D')}-${this.endDate.format('D, YYYY')}`;
    } else if (this.timePeriod === TimePeriods.Month) {
      return this.startDate.format('MMMM YYYY');
    } else if (this.timePeriod === TimePeriods.Quarter) {
      return `${this.startDate.format('MMM D')}-${this.endDate.format('MMM D, YYYY')}`;
    } else if (this.timePeriod === TimePeriods.Year) {
      return this.startDate.format('YYYY');
    }

    return this.startDate.format('MMM D, YYYY');
  }

  public getSource() {
    return {
      dimensions: { ...this.dimensions },
      localeMoment: this.localeMoment,
      renderedEvents: [...this.renderedEvents],
      xAxis: [...this.xAxis],
      yAxis: [...this.yAxis],
    } as SchedulerSource;
  }

  public setTimePeriod(timePeriod: TimePeriod) {
    this.timePeriod = timePeriod;
    this.resolveDateRange(this.currentDate);
    this.reloadAll();
  }

  public recalDimensions(containerWidth: number, labelWidth: number) {
    this.dimensions.containerWidth = containerWidth;
    this.dimensions.labelWidth = labelWidth;
    this.dimensions.dataWidth = containerWidth - labelWidth;
    this.calculateXAxisWidth();
    this.calculateRenderedEventWidth();
  }

  public setDate(date?: moment.Moment) {
    const val = date ? date.locale(this.language) : moment().locale(this.language);
    this.resolveDateRange(val);
    this.events = [];
    this.generateXAxis();
    this.generateRenderedEvents();
  }

  public setEventGroupsAutoGenerated(autoGenerated: boolean) {
    this.eventGroupsAutoGenerated = autoGenerated;
  }

  public setEvents(events: Event[]) {
    if (events.length > 0) {
      this.validateEvents(events);
      this.events = events;

      if (this.eventGroupsAutoGenerated) {
        this.generateEventGroups();
      }

      if (this.config.recurringEventsEnabled) {
        this.handleRecurringEvents();
      }

      this.generateRenderedEvents();
    }
  }

  public setMinuteStep(minuteStep: number) {
    if (this.minuteStep !== minuteStep) {
      this.validateMinuteStep(minuteStep);
      this.minuteStep = minuteStep;
      this.generateXAxis();
      this.generateRenderedEvents();
    }
  }

  public setResources(resources: Resource[]) {
    if (resources.length > 0) {
      this.validateResource(resources);
      this.resources = resources;
      this.generateRenderedEvents();
    }
  }

  // =============================================================================
  // PRIVATE METHODS
  // =============================================================================

  /**
   * Attach an event into the event array at the specific position.
   * @param event An event object.
   */
  private attachEvent(event: Event) {
    let pos = 0;
    const eventStart = this.localeMoment(event.start);
    this.events.forEach((evt, index) => {
      const start = this.localeMoment(evt.start);
      if (eventStart >= start) {
        pos = index + 1;
      }
    });
    this.events.splice(pos, 0, event);
  }

  private calculateDataHeight() {
    this.dimensions.dataHeight = 0;
    this.yAxis.forEach(y => {
      if (y.render) {
        this.dimensions.dataHeight += y.height;
      }
    });
  }

  private calculateDataSlotWidth() {
    if (
      this.timePeriod === TimePeriods.Day ||
      this.timePeriod === TimePeriods.Week ||
      this.timePeriod === TimePeriods.Month
    ) {
      this.dimensions.dataSlotWidth = Number(
        (this.dimensions.dataWidth / this.xAxis.length).toFixed(0),
      );
      this.dimensions.minimumDataSlotWidth =
        this.timePeriod === TimePeriods.Week
          ? Number((this.dimensions.dataWidth / (7 * 24)).toFixed(0))
          : this.timePeriod === TimePeriods.Month
          ? Number((this.dimensions.dataSlotWidth / (this.xAxis.length * 24)).toFixed(0))
          : Number((this.dimensions.dataWidth / (24 * 60)).toFixed(0));
    } else {
      this.dimensions.dataSlotWidth = this.config.defaultDataUnitLength;
      this.dimensions.minimumDataSlotWidth = Number(
        (this.dimensions.dataSlotWidth / (this.xAxis.length * 24)).toFixed(0),
      );
    }
  }

  private calculateRenderedEventWidth() {
    if (
      this.dimensions.containerWidth > 0 &&
      this.dimensions.labelWidth > 0 &&
      this.xAxis.length > 0 &&
      this.yAxis.length > 0
    ) {
      this.renderedEvents.forEach(e => {
        let renderedUnit = 0;
        let index;
        e.startPosition = -1;

        for (index = 0; index < this.xAxis.length; index++) {
          if (
            e.startTime >= this.xAxis[index].startTime &&
            e.startTime < this.xAxis[index].endTime
          ) {
            e.startPosition = index * this.dimensions.dataSlotWidth;
          }

          if (e.endTime >= this.xAxis[index].startTime && e.endTime <= this.xAxis[index].endTime) {
            renderedUnit++;
            break;
          } else {
            if (e.startPosition > -1) {
              renderedUnit++;
            }
          }
        }

        e.length =
          index === this.xAxis.length - 1
            ? renderedUnit * this.dimensions.dataSlotWidth
            : renderedUnit * this.dimensions.dataSlotWidth;
      });

      // Align top.
      this.yAxis.forEach(y => {
        y.relatedIds.forEach((e, eIndex) => {
          const index = this.renderedEvents.findIndex(r => r.id.toString() === e.toString());
          if (index > -1) {
            this.renderedEvents[index].top = eIndex * this.eventHeight;
          }
        });
      });
    }
  }

  private calculateXAxisWidth() {
    if (
      this.dimensions.containerWidth > 0 &&
      this.dimensions.labelWidth > 0 &&
      this.xAxis.length > 0
    ) {
      this.calculateDataSlotWidth();

      // Re-assign all x-axis length.
      this.xAxis.forEach((x, indx) => {
        x.length = indx === this.xAxis.length - 1 ? 0 : this.dimensions.dataSlotWidth;
      });
    }
  }

  private calculateYAxisHeight() {
    const endDate =
      this.timePeriod === TimePeriods.Day
        ? this.localeMoment(this.endDate.toDate()).add(1, 'days')
        : this.endDate;

    // Loop through all events.
    this.events.forEach(evt => {
      // Find the y-axis that matches an event and then re-calculate the height.
      this.yAxis.forEach(y => {
        if (y.id.toString() === this.getEventResourceId(evt)) {
          const startTime = this.localeMoment(evt.start, DATETIME_FORMAT);

          if (
            startTime.isSameOrBefore(endDate) &&
            y.relatedIds.findIndex(r => r.toString() === evt.id.toString()) === -1
          ) {
            y.relatedIds.push(evt.id);
          }

          y.height = y.relatedIds.length * this.eventHeight;
        }

        if (y.height < this.yAxisHeight) {
          y.height = this.yAxisHeight;
        }
      });
    });
  }

  private detachEvent(event: Event) {
    const index = this.events.indexOf(event);
    if (index !== -1) {
      this.events.splice(index, 1);
    }
  }

  private generateRenderedEvents() {
    // Sort event by date.
    this.events.sort((d1, d2) => {
      const dt1 = this.localeMoment(d1.start, DATETIME_FORMAT);
      const dt2 = this.localeMoment(d2.start, DATETIME_FORMAT);

      if (dt1.isAfter(dt2)) {
        return 1;
      } else if (dt1.isBefore(dt2)) {
        return -1;
      } else {
        return 1;
      }
    });

    this.renderedEvents = [];

    // Loop through all events.
    this.events.forEach(e => {
      // Find the Y-Axis match with an event.
      const yAxis = this.yAxis.filter(
        y => y.id.toString() === this.getEventResourceId(e).toString(),
      );

      if (yAxis.length > 0) {
        const renderdEvents: RenderedEvent[] = [];

        yAxis.forEach(y => {
          const yAxisIndex = this.yAxis.findIndex(yy => yy.id.toString() === y.id.toString());

          renderdEvents.push({
            id: e.id,
            bgColor: e.bgColor,
            endTime: this.localeMoment(e.end, DATETIME_FORMAT).toDate(),
            groupId: 0,
            groupName: '',
            height: this.eventHeight,
            length: 0,
            resourceId: y.id,
            rrule: e.rrule,
            startPosition: 0,
            startTime: this.localeMoment(e.start, DATETIME_FORMAT).toDate(),
            text: e.text,
            top: 0,
            yAxisIndex,
          } as RenderedEvent);
        });

        this.renderedEvents.push(...renderdEvents);
      }
    });
  }

  private generateEventGroups() {
    this.eventGroups = [];
    const set = new Set();
    this.events.forEach(event => {
      const id = this.getEventGroupId(event);
      const text = this.getEventGroupName(event);

      if (!set.has(id)) {
        this.eventGroups.push({
          id,
          text,
          event,
        });

        set.add(id);
      }
    });
  }

  private generateTimeSlotXaxis() {
    const start = this.localeMoment(this.startDate.toDate());
    const end = this.localeMoment(this.endDate.toDate());

    if (this.timePeriod === TimePeriods.Day) {
      start.add(this.startTimeOfDay, 'hours');
      end.add(this.endTimeOfDay, 'hours');
      const minuteSteps = 60 / this.minuteStep;

      while (start.isSameOrBefore(end)) {
        for (let i = 0; i < minuteSteps; i++) {
          const hour = start.hour();
          if (hour >= this.startTimeOfDay && hour <= this.endTimeOfDay) {
            const workingTime = isWorkingTime(start, this.cellUnit);
            const startTime = start.toDate();
            const endTime = start.add(minuteSteps, 'hours').toDate();
            this.xAxis.push({
              endTime,
              length: 0,
              startTime,
              workingTime,
            });
          }
        }
      }
    } else {
      while (start.isSameOrBefore(end)) {
        const workingTime = isWorkingTime(start, this.cellUnit);
        const startTime = start.toDate();
        const endTime = start.add(1, 'days').toDate();
        this.xAxis.push({
          endTime,
          length: 0,
          startTime,
          workingTime,
        });
      }
    }
  }

  /**
   * Generate X-Axis based on the view type.
   */
  private generateXAxis() {
    this.xAxis = [];

    if (this.viewType === ViewTypes.Agenda) {
      this.xAxis.push({
        endTime: this.startDate.toDate(),
        startTime: this.startDate.toDate(),
        length: 0,
        workingTime: false,
      });
    } else if (this.viewType === ViewTypes.Timeline) {
      this.generateTimeSlotXaxis();
    }
  }

  /**
   * Generate Y-Axis based on the resources.
   */
  private generateYAxis() {
    const rows = this.yAxisDataType === YAxisDataTypes.Resource ? this.resources : this.eventGroups;
    const rowTree: any[] = [];
    const rowMap = new Map();

    // Loop through each resource.
    rows.forEach(r => {
      const y: YAxis = {
        id: r.id,
        text: r.text,
        parentId: r.parentId,
        groupOnly: r.groupOnly || false,
        hasSummary: false,
        relatedIds: [],
        height: this.eventHeight,
        indent: 0,
        hasChildren: false,
        expanded: true,
        render: true,
      };
      let value;

      if (rowMap.has(r.id)) {
        value = rowMap.get(r.id);
        value.data = y;
      } else {
        value = {
          data: y,
          children: [],
        };
        rowMap.set(r.id, value);
      }

      const parentId = r.parentId;
      if (!parentId || parentId === r.id) {
        rowTree.push(value);
      } else {
        let parentValue;
        if (rowMap.has(parentId)) {
          parentValue = rowMap.get(parentId);
        } else {
          parentValue = {
            data: undefined,
            children: [],
          };
          rowMap.set(parentId, parentValue);
        }

        parentValue.children.push(value);
      }
    });

    const slotStack = [];
    let i;
    for (i = rowTree.length - 1; i >= 0; i--) {
      slotStack.push(rowTree[i]);
    }

    this.yAxis = [];
    let currentNode;
    while (slotStack.length > 0) {
      currentNode = slotStack.pop();
      if (currentNode.data.indent > 0) {
        currentNode.data.render = this.config.defaultExpanded;
      }
      if (currentNode.children.length > 0) {
        currentNode.data.hasChildren = true;
        currentNode.data.expanded = this.config.defaultExpanded;
      }
      this.yAxis.push(currentNode.data);

      for (i = currentNode.children.length - 1; i >= 0; i--) {
        currentNode.children[i].data.indent = currentNode.data.indent + 1;
        slotStack.push(currentNode.children[i]);
      }
    }
  }

  private getEventResourceId(event: Event) {
    return this.yAxisDataType === YAxisDataTypes.Resource
      ? event.resourceId
      : this.getEventGroupId(event);
  }

  private getEventGroupId(event: Event) {
    return !!event.groupId ? event.groupId.toString() : event.id.toString();
  }

  private getEventGroupName(event: Event) {
    return !!event.groupName ? event.groupName : event.text;
  }

  private handleRecurringEvents() {
    const recurringEvents = this.events.filter(x => !!x.rrule);
    recurringEvents.forEach(event => {
      this.detachEvent(event);
    });

    recurringEvents.forEach(event => {
      const windowStart = this.localeMoment(this.startDate);
      const windowEnd = this.localeMoment(this.endDate).add(1, 'days');
      const eventStart = this.localeMoment(event.start);
      const eventEnd = this.localeMoment(event.end);
      let rule = rrulestr(event.rrule || '');
      const oldDtstart = !!rule.origOptions.dtstart
        ? this.localeMoment(rule.origOptions.dtstart)
        : undefined;

      if (!rule.origOptions.until || windowEnd < this.localeMoment(rule.origOptions.until)) {
        rule.origOptions.until = windowEnd.toDate();
      }

      // reload
      rule = rrulestr(rule.toString());
      /* if (event.exdates || event.exrule) {
        const rruleSet = new RRuleSet();
        rruleSet.rrule(rule);
        if (event.exrule) {
          rruleSet.exrule(rrulestr(event.exrule));
        }
        if (event.exdates) {
          event.exdates.forEach(exdate => {
            rruleSet.exdate(this.localeMoment(exdate).toDate());
          });
        }
        rule = rruleSet;
      } */

      const all = rule.all();
      const newEvents: Event[] = all.map((time, index) => {
        return {
          ...event,
          recurringEventId: event.id,
          recurringEventStart: event.start,
          recurringEventEnd: event.end,
          id: `${event.id}-${index}`,
          start: rule.origOptions.tzid
            ? this.localeMoment
                .utc(time)
                .utcOffset(this.localeMoment().utcOffset(), true)
                .format(DATETIME_FORMAT)
            : this.localeMoment(time).format(DATETIME_FORMAT),
          end: rule.origOptions.tzid
            ? this.localeMoment
                .utc(time)
                .utcOffset(this.localeMoment().utcOffset(), true)
                .add(eventEnd.diff(eventStart), 'ms')
                .format(DATETIME_FORMAT)
            : this.localeMoment(time)
                .add(eventEnd.diff(eventStart), 'ms')
                .format(DATETIME_FORMAT),
        };
      });

      newEvents.forEach(newEvent => {
        const newEventStart = this.localeMoment(newEvent.start);
        const newEventEnd = this.localeMoment(newEvent.end);

        if (
          newEventStart < windowEnd &&
          newEventEnd > windowStart &&
          (!oldDtstart || newEventStart >= oldDtstart)
        ) {
          this.attachEvent(newEvent);
        }
      });
    });
  }

  private reloadAll() {
    this.generateXAxis();
    this.generateYAxis();
    this.calculateXAxisWidth();
    this.calculateYAxisHeight();
    this.calculateDataHeight();
    this.generateRenderedEvents();
    this.calculateRenderedEventWidth();
    console.log(this.dimensions);
  }

  private resolveDateRange(date: moment.Moment) {
    if (this.timePeriod === TimePeriods.Day) {
      this.startDate = date
        ? this.localeMoment(date.format(DATETIME_FORMAT), DATETIME_FORMAT)
        : this.localeMoment(this.startDate).add(0, 'days');
      this.endDate = this.localeMoment(this.startDate, DATETIME_FORMAT).add(0, 'days');
    } else if (this.timePeriod === TimePeriods.Week) {
      this.startDate = date
        ? this.localeMoment(date.format(DATETIME_FORMAT)).startOf('week')
        : this.localeMoment(this.startDate).add(0, 'weeks');
      this.endDate = this.localeMoment(this.startDate).endOf('week');
    } else if (this.timePeriod === TimePeriods.Month) {
      this.startDate = date
        ? this.localeMoment(date.format(DATETIME_FORMAT)).startOf('month')
        : this.localeMoment(this.startDate).add(0, 'months');
      this.endDate = this.localeMoment(this.startDate).endOf('month');
    } else if (this.timePeriod === TimePeriods.Quarter) {
      this.startDate = date
        ? this.localeMoment(date.format(DATETIME_FORMAT)).startOf('quarter')
        : this.localeMoment(this.startDate).add(0, 'quarters');
      this.endDate = this.localeMoment(this.startDate).endOf('quarter');
    } else if (this.timePeriod === TimePeriods.Year) {
      this.startDate = date
        ? this.localeMoment(date.format(DATETIME_FORMAT)).startOf('year')
        : this.localeMoment(this.startDate).add(0, 'years');
      this.endDate = this.localeMoment(this.startDate).endOf('year');
    }
  }

  private validateEvents(events: Event[]) {
    if (Object.prototype.toString.call(events) !== '[object Array]') {
      throw new Error('Events should be Array object');
    }

    events.forEach((evt, index) => {
      if (!evt) {
        console.error(`Event undefined: ${index}`);
        throw new Error(`Event undefined: ${index}`);
      }

      if (!evt.id || !evt.resourceId || !evt.text || !evt.start || !evt.end) {
        console.error('Event property missed', index, evt);
        throw new Error(`Event property undefined: ${index}`);
      }
    });
  }

  private validateMinuteStep(minuteStep: number) {
    if (60 % minuteStep !== 0) {
      console.error(
        'Minute step is not set properly - 60 minutes must be divisible without remainder by this number',
      );
      throw new Error(
        'Minute step is not set properly - 60 minutes must be divisible without remainder by this number',
      );
    }
  }

  private validateResource(resources: Resource[]) {
    if (Object.prototype.toString.call(resources) !== '[object Array]') {
      throw new Error('Resources should be Array object');
    }

    resources.forEach((r, index) => {
      if (!r) {
        console.error(`Resource undefined: ${index}`);
        throw new Error(`Resource undefined: ${index}`);
      }
      if (!r.id || !r.text) {
        console.error('Resource property missed', index, r);
        throw new Error(`Resource property undefined: ${index}`);
      }
    });
  }
}
